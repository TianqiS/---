### js相关

- **instanceOf**
  
  instanceof 是用于判断对象是否为某个构造函数的实例

- **Boolean(0)和new Boolean(0)的区别**
  
  前者是作为[构造函数](https://www.baidu.com/s?wd=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)构造一个Boolean实例，得到的是一个对象，后者是作为普通函数调用，得到的是函数返回值false。

- **js的变量所占字节**
  
  1.Javascript中，由于其变量内容不同，变量被分为基本数据类型变量和引用数据类型变量。基本类型变量用八字节内存，存储基本数据类型(数值、布尔值、null和未定义)的值，引用类型变量则只保存对对象、数组和函数等引用类型的值的引用(即内存地址)。
  
  **2.** JS中的数字是不分类型的，也就是没有byte/int/float/double等的差异。

- **Promise和setTimeout执行顺序**

- **Number() 函数**
  
  **定义和用法**
  
  Number() 函数把对象的值转换为数字。
  
  **语法**
  
  Number(object)
  
  | 参数     | 描述                |
  | ------ | ----------------- |
  | object | 必需。JavaScript 对象。 |
  
  **返回值**
  
  如果参数是 Date 对象，Number() 返回从 1970 年 1 月 1 日至今的毫秒数。
  
  如果对象的值无法转换为数字，那么 Number() 函数返回 NaN。
  
  **实例**
  
  在本例中，我们将尝试把不同的对象转换为数字：
  
  ```js
  <script type="text/javascript">
  
  var test1= new Boolean(true);
  var test2= new Boolean(false);
  var test3= new Date();
  var test4= new String("999");
  var test5= new String("999 888");
  
  document.write(Number(test1)+ "<br />");
  document.write(Number(test2)+ "<br />");
  document.write(Number(test3)+ "<br />");
  document.write(Number(test4)+ "<br />");
  document.write(Number(test5)+ "<br />");
  
  </script>
  ```
  
  输出：

```js
  1
  0
  1256657776588
  999
  NaN
```

### html和css相关

- **行内替换元素和行内非替换元素**
  
  行内替换元素。height/width/padding/margin均可用。效果等于块元素。 
  行内非替换元素，例如, height/width/padding top、bottom/margin top、bottom均无效果。只能用padding left、right和padding left、right改变宽度。

- **锚伪类**
  
  在支持 css 的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：**活动状态**，**已被访问状态**，**未被访问状态和鼠标悬停状态**。用来表示链接不同状态的伪类就是锚伪类。
  
  `a:link {``color``:` `green``;}` `/* 未访问的链接 */`
  
  `a:visited {``color``:` `blue``;}` `/* 已访问的链接 */`
  
  `a:hover {``color``:orange;}` `/* 鼠标移动到链接上 */`
  
  `a:active {``color``: yellow;}` `/* 选定的链接 */`
  
  - 几个伪类必须按照一定的顺序(l-v-h-a)，a:hover必须被置于a:link和a:visited之后，才是有效的；a:active必须被置于a:hover之后，才是有效的。
  - 书写顺序很重要：a:link - a:visited - a:hover - a:actived。

### 其他

- 面向对象的三个基本特性(转自[转自CSDN](https://blog.csdn.net/cancan8538/article/details/8057095))
  
  面向对象的三个基本特征是：**封装**、**继承**、**多态**。

![](C:\Users\宋大帅\AppData\Roaming\marktext\images\2020-02-10-10-42-27-image.png)

**封装**

封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。

封装，也就是**把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作**，对不可信的进行信息隐藏。

**继承**

面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或“派生类”。

被继承的类称为“基类”、“父类”或“超类”。

继承的过程，就是从一般到特殊的过程。

要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。

在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

继承概念的实现方式有三类：实现继承、接口继承和可视继承。

Ø         实现继承是指使用基类的属性和方法而无需额外编码的能力；

Ø         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

Ø         可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。

在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。

抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 Interface 而不是 Class。

OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。

**多态**

多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

实现多态，有二种方式，覆盖，重载。

覆盖，是指子类重新定义父类的虚函数的做法。

重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。”

那么，多态的作用是什么呢？

我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。

- **浏览器的标准模式和混杂模式**(转自[简书](https://www.jianshu.com/p/4aa37da38b81))
  
  **关于渲染模式：** 
  在多年以前（IE6诞生以前），各浏览器都处于各自比较封闭的发展中（基本没有兼容性可谈）。随着WEB的发展，兼容性问题的解决越来 
  越显得迫切，随即，各浏览器厂商发布了按照标准模式（遵循各厂商制定的统一标准）工作的浏览器，比如IE6就是其中之一。但是考虑到以 
  前建设的网站并不支持标准模式，所以各浏览器在加入标准模式的同时也保留了混杂模式（即以前那种未按照统一标准工作的模式，也叫怪 
  异模式）。经过多年的发展，后来又出现了近似标准模式（在一种模式中同时融入标准模式和部分混杂模式的特性，也称为接近标准模式、 
  准标准模式、最有限混杂模式）和超级标准模式（近似标准模式、标准模式、超级标准模式三者也共同被称作标准模式）。因此，浏览器的 
  模式可以分为两类：标准模式和混杂模式，其中，标准模式又可更严格的分为近似标准模式、标准模式、超级标准模式。 
  需要注意的是，不同厂商浏览器的标准模式也是有细微差别的（这是标准实现程度的问题）。此外，同品牌不同版本浏览器的标准模式也是 
  有差别的，比如IE6&IE7时代的标准模式在现在看来或许已经不那么标准了（IE8和IE9都在不断的提高标准的实现程度，因此差距越来越大是 
  必然的），但尽管如此它们依然叫做标准模式，毕竟它们在那个特定时代那个特定版本中确实是按照尽可能遵循标准的方式工作的。 
  **什么是DOCTYPE：** 
  DOCTYPE，或者称为 Document Type Declaration（文档类型声明，缩写 DTD）。通常情况下，DOCTYPE 位于一个 HTML 文档的最前面的 
  位置，位于根元素 HTML 的起始标签之前。这样一来，在浏览器解析 HTML 文档正文之前就可以确定当前文档的类型，以决定其需要采用的 
  渲染模式（不同的渲染模式会影响到浏览器对于 CSS 代码甚至 JavaScript 脚本的解析）。 
  **DOCTYPE与各种模式的关系：** 
  混杂模式： 
  不写DOCTYPE 
  近似标准模式： 
  
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">

  标准模式： 

<!DOCTYPE html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

  我们可以看到，过渡型或框架型HTML声明与过渡型或框架型XHTML声明均可使浏览器进入近似标准模式，同时，html5的DOCTYPE声明和严 
  格型HTML声明以及严格型XHTML声明则会使浏览器进入标准模式。 
  **三种模式下的表现差异：** 
  首先，混杂模式是不可取的，因为其没有兼容性可言。在IE（IE6~IE9）中，混杂模式即使用IE5.5内核来解析并渲染页面。其次，近似标准 
  模式是在尽可能遵循标准的基础上兼容部分非标准代码，比如一些已经弃用的标签等。标准模式则是对统一标准实现最好的模式，它要求标 
  签必须闭合（唯一不需要闭合的就是DOCTYPE标签），不能使用已经废弃的标签等等。目前，使用最多的DOCTYPE声明为过渡型HTML或 
  XHTML，因为它能最大话的兼容一些老代码。不过，技术领先的公司（比如google、facebook、twitter等都如此）都已经使用了html5的 
  DOCTYPE声明，即<!DOCTYPE html>，它所触发的模式与严格型HTML或严格型XHTML所触发的模式完全相同，但好处是节省代码且向前兼 
  容（HTML5时代）。 
  **其它激活混杂模式的情况：** 
  前面已经介绍了，当我们**不写DOCTYPE声明时，所有浏览器都会进入混杂模式**。但是也存在一些因其他情况而进入混杂模式的时候，这些情 
  况都是我们应该避免的，最常见的就是在DOCTYPE声明前面出现了这些内容：普通文本、HTML 标签、HTML 注释、XML 声明、IE条件注 
  释。对于普通文本和HTML标签，各浏览器均进入了混杂模式，这个很好理解，都看到疑似的HTML文档正文了，浏览器就不需要再往下追查 
  DOCTYPE在哪里了。对于HTML注释和XML声明，它们和上面的普通文本和HTML标签有些差别，它们不会在页面中展示出来，即不可视。这 
  时，有的浏览器则显得十分“智能”，非IE浏览器均会忽略它们的存在，DOCTYPE 被正确解析。但是在IE6中，DOCTYPE之前的 XML 声明会导 
  致页面进入混杂模式，而如果DOCTYPE之前出现了HTML注释，则所有IE都会进入混杂模式。有的作者很聪明，他既在DOCTYPE之前加入了 
  他需要的内容，却又没有使IE由于这些内容而进入混杂模式。他可能会这么写：

```html
  <![if !IE]><![endif]>
  <![if false]><![endif]>
```

上面这些IE条件注释在非IE浏览器中，可能完全被忽略，可能被解释为普通HTML注释。但是在IE中它们全部消失了，因为这就是IE条件注释 
的作用。所以这也是目前比较合适的在DOCTYPE之前写点什么又保证所有浏览器均为标准模式的做法，但我们仍然不推荐在DOCTYPE之前 
加入任何非空白内容。 
**用JS判断浏览器当前的模式：** 
`document.write(document.compatMode == "CSS1Compat" ? "当前处于标准模式" : "当前处于混杂模式");`
